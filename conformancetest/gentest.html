<!doctype html>
<meta charset=utf-8>
<link rel=stylesheet href=../css/reset.css>
<title>Generator for editing conformance tests</title>
<p>See the <a href=editing.html#tests>Tests</a> section of the specification
for documentation.

<p><button onclick="generateTests(); this.parentNode.removeChild(this)">Generate all tests</button>

<p id=timing></p>

<div id=errors></div>

<pre id=output></pre>

<div id=test-container></div>

<script src=../implementation.js></script>
<script>var testsJsLibraryOnly = true</script>
<script src=../tests.js></script>
<script>
"use strict";

function generateTests() {
	var startTime = Date.now();
	document.getElementById("test-container").innerHTML = "<div contenteditable></div><p>test";

	var outputEl = document.getElementById("output");
	outputEl.textContent = "var browserTests = [\n";
	for (var command in tests) {
		tests[command].forEach(function(test) {
			if (badTests[command].indexOf(test) != -1) {
				return;
			}
			try {
				if (command == "multitest") {
					generateTest(normalizeTest(command, test));
				} else if (doubleTestingCommands.indexOf(command) != -1) {
					generateTest(normalizeTest(command, test, false));
					generateTest(normalizeTest(command, test, true));
				} else {
					generateTest(normalizeTest(command, test, false));
				}
			} catch(e) {
				var errorP = document.createElement("p");
				errorP.textContent = "Exception, "
					+ command + " " + JSON.stringify(test) + ": "
					+ formatException(e);
				document.getElementById("errors").appendChild(errorP);
			}
		});
	}

	// Finish up our JSON.  First remove the last comma, since JSON doesn't
	// like that, then add a closing bracket.
	outputEl.firstChild.deleteData(outputEl.textContent.lastIndexOf(","), 1);
	outputEl.firstChild.appendData("]");

	document.getElementById("test-container").parentNode
		.removeChild(document.getElementById("test-container"));
	var elapsed = Math.round(Date.now() - startTime)/1000;
	document.getElementById("timing").textContent =
		"Time elapsed: " + Math.floor(elapsed/60) + ":" + (elapsed % 60) + " min.";
	getSelection().selectAllChildren(document.getElementById("output"));
}

/**
 * Input is in the format generated by normalizeTest:
 *   [input HTML, [command, value], [command, value], . . .]
 * Converts to something of the following form:
 *   [input HTML,
 *    array of commands,
 *    expected output HTML,
 *    array of expected indeterm/state/value].
 * The array of commands is [[command, value], [command, value], ...].  The
 * indeterm/state/value array is zero or more entries of the form
 *   [command, expected indeterm before, expected state before,
 *    expected value before, expected indeterm after,
 *    expected state after, expected value after].
 * null for any of the last six entries means an INVALID_ACCESS_ERR must be
 * raised.
 *
 * The converted test value is then added to the pre with id=output.
 */
function generateTest(test) {
	var output = document.getElementById("output").firstChild;

	var testDiv = document.querySelector("div[contenteditable]");
	var points = setupDiv(testDiv, test[0]);

	// Hack around Firefox bug when generating the tests, although we don't
	// want to give it a pass when actually running them:
	// https://bugzilla.mozilla.org/show_bug.cgi?id=618737
	[].forEach.call(testDiv.querySelectorAll("video[tabindex]"), function(video) {
		if (video.tabIndex == 0) {
			video.removeAttribute("tabindex");
		}
	});

	var range = document.createRange();
	range.setStart(points[0], points[1]);
	range.setEnd(points[2], points[3]);
	// The points might be backwards
	if (range.collapsed) {
		range.setEnd(points[0], points[1]);
	}

	// Verify that we aren't touching any non-editable nodes
	var nonEditable = getDescendants(testDiv).filter(function(node) {
		return !isEditable(node);
	});
	var nonEditableClones = nonEditable.map(function(node) {
		return node.cloneNode(false);
	});

	for (var i = 1; i < test.length; i++) {
		myExecCommand(test[i][0], false, test[i][1], range);
	}

	for (var i = 0; i < nonEditable.length; i++) {
		if (!isDescendant(nonEditable[i], testDiv)) {
			throw "Non-editable node " + i + " is no longer descendant of test div: "
				+ nonEditable[i];
		}
		if (!nonEditableClones[i].isEqualNode(nonEditable[i].cloneNode(false))) {
			throw "Non-editable node " + i + " has changed: "
				+ nonEditable[i];
		}
	}

	var compareDiv1 = testDiv.cloneNode(true);

	// Now do various sanity checks, and throw if they're violated.  First
	// just count children:
	if (testDiv.parentNode.childNodes.length != 2) {
		throw "The cell didn't have two children.  Did something spill outside the test div?";
	}

	// Now verify that the DOM serializes.
	compareDiv1.normalize();
	var compareDiv2 = compareDiv1.cloneNode(false);
	compareDiv2.innerHTML = compareDiv1.innerHTML;
	// Oddly, IE9 sometimes produces two nodes that return true for
	// isEqualNode but have different innerHTML (omitting closing tags vs.
	// not).
	if (!compareDiv1.isEqualNode(compareDiv2)
	&& compareDiv1.innerHTML != compareDiv2.innerHTML) {
		throw "DOM does not round-trip through serialization!  "
			+ prettyPrint(compareDiv1.innerHTML) + " vs. " + prettyPrint(compareDiv2.innerHTML);
	}
	if (!compareDiv1.isEqualNode(compareDiv2)) {
		throw "DOM does not round-trip through serialization (although innerHTML is the same)!  "
			+ prettyPrint(compareDiv1.innerHTML);
	}

	// Check for attributes
	if (testDiv.attributes.length != 1) {
		throw "Wrapper div has extra attributes!  " +
			prettyPrint(testDiv.parentNode.innerHTML);
	}

	// Final sanity check: make sure everything isAllowedChild() of its
	// parent.
	getDescendants(testDiv).forEach(function(descendant) {
		if (!isAllowedChild(descendant, descendant.parentNode)) {
			throw "Something here is not an allowed child of its parent: " + descendant;
		}
	});

	normalizeSerializedStyle(testDiv);

	addBrackets(range);

	output.appendData("[" + JSON.stringify(test[0]) + ",\n"
		+ "\t" + JSON.stringify(test.slice(1)) + ",\n"
		+ "\t" + JSON.stringify(testDiv.innerHTML) + ",\n"
		+ "\t" + JSON.stringify([]) + "],\n");
}
</script>
